# CI-Dokumentation

## Table of content

  - [`.github/workflows/ci.yml` – Erste Stufe CI](#githubworkflowsciyml-erste-stufe-ci)
  - [ASCII-FLowdiagramm](#ascii-flowdiagramm)
  - [Tabellendarstellung](#tabellendarstellung)
    - [CI-Workflow](#ci-workflow)
    - [Test-Report Workflow](#test-report-workflow)
  - [Kopfbereich](#kopfbereich)
  - [Jobs](#jobs)
    - [build-and-test](#build-and-test)
    - [Schritte](#schritte)
      - [Repository auschecken](#repository-auschecken)
      - [Node-Module Cache](#node-module-cache)
      - [Node-Abhängigkeiten installieren](#node-abhngigkeiten-installieren)
      - [Linting](#linting)
      - [Vitest Test-Ordner vorbereiten](#vitest-test-ordner-vorbereiten)
      - [Vitest ausführen](#vitest-ausfhren)
      - [Lua-Testordner vorbereiten](#lua-testordner-vorbereiten)
      - [Podman-Maschine starten](#podman-maschine-starten)
      - [Lua-Tests via Container](#lua-tests-via-container)
      - [Test-Ergebnisse hochladen](#test-ergebnisse-hochladen)
      - [Node-Build](#node-build)
      - [Node-Build-Artefakte hochladen](#node-build-artefakte-hochladen)
    - [Kopfbereich](#kopfbereich-1)
    - [Job: publish-report](#job-publish-report)
    - [Schritte](#schritte-1)
      - [Artefakt herunterladen](#artefakt-herunterladen)
      - [Diagnose der Artefakte](#diagnose-der-artefakte)
      - [Vitest-Report veröffentlichen](#vitest-report-verffentlichen)
      - [Busted-Report veröffentlichen](#busted-report-verffentlichen)

---

## `.github/workflows/ci.yml` – Erste Stufe CI

**Zweck:**
Dieser Workflow führt die eigentlichen Tests und Build-Schritte aus, erzeugt JUnit XML Testberichte und lädt diese als Artefakt hoch. **Er erstellt keine CheckRuns**, damit er auch bei PRs von Forks funktioniert. Die Testreports werden im zweiten Workflow veröffentlicht.

## ASCII-FLowdiagramm

Hier ist ein ASCII-basiertes Flussdiagramm, das die beiden Workflows und ihre Abhängigkeiten visuell darstellt:

```sh
                       ┌─────────────────────┐
                       │     GitHub Push      │
                       │   oder Pull Request │
                       └─────────┬──────────┘
                                 │
                                 ▼
                       ┌─────────────────────┐
                       │      CI Workflow    │
                       │  (.github/workflows/│
                       │        ci.yml)      │
                       └─────────┬──────────┘
                                 │
          ┌──────────────────────┼───────────────────────┐
          │                      │                       │
          ▼                      ▼                       ▼
┌─────────────────┐     ┌─────────────────┐     ┌───────────────────┐
│ Node.js/TS Steps│     │ Lua Steps        │     │ Build Client      │
│ - checkout      │     │ - create output  │     │ - npm run build   │
│ - cache modules │     │   dir            │     │ - upload artifacts│
│ - npm ci        │     │ - run Busted     │     └───────────────────┘
│ - lint          │     │   (container)    │
│ - vitest test   │     └─────────────────┘
│ - produce JUnit │
└─────────────────┘
          │
          ▼
┌─────────────────────┐
│ Upload test-results │
│ artifact (Vitest +  │
│ Busted XML)         │
└─────────┬───────────┘
          │
          ▼
 ┌─────────────────────┐
 │  Test Report        │
 │ workflow            │
 │ (.github/workflows/ │
 │ test-report.yml)    │
 └─────────┬───────────┘
           │
   ┌───────┴────────┐
   ▼                ▼
┌───────────────┐  ┌───────────────┐
│ Publish Vitest│  │ Publish Busted│
│ CheckRun      │  │ CheckRun      │
│ in GitHub UI  │  │ in GitHub UI  │
└───────────────┘  └───────────────┘
```

**Beschreibung:**

1. **Trigger:** Push oder Pull Request auf `main`.
2. **CI Workflow:**

   * Node.js/TypeScript: checkout, caching, dependencies, lint, Vitest Tests, Build.
   * Lua: optional Busted Tests über Podman/Docker Container.
   * Artefakte: Test-XML-Dateien + gebaute Client-Dateien.
3. **Test-Report Workflow:**

   * Läuft auf Default-Branch, nachdem CI abgeschlossen ist.
   * Lädt Artefakte herunter.
   * Erstellt CheckRuns für Vitest und Busted.
4. **Vorteil der Trennung:** PRs von Forks können trotzdem getestet werden, auch wenn sie keine Berechtigungen haben, CheckRuns direkt zu erstellen.
5. **Containerisierung:** Sichert konsistente Linux-Umgebung für Lua/Busted, unabhängig vom Self-Hosted Runner OS.

---

## Tabellendarstellung

### CI-Workflow

Hier ist eine übersichtliche Tabelle, die jeden Schritt des CI-Workflows inklusive Plattform, Input/Output und Zweck beschreibt:

```
| Job/Step                          | Platform       | Input/Resources                         | Output/Artifacts                      | Zweck/Beschreibung                                                                 |
|----------------------------------|----------------|----------------------------------------|---------------------------------------|-----------------------------------------------------------------------------------|
| Checkout repository               | cross-platform | GitHub repo                             | Arbeitsverzeichnis mit Code           | Klont das Repository, damit die nachfolgenden Steps Zugriff auf Quellcode haben.  |
| Cache node modules                | cross-platform | package-lock.json                        | ~/.npm cached modules                  | Schnelleres Build durch Wiederverwendung bereits installierter Node-Module.      |
| Install dependencies (npm ci)     | cross-platform | package.json / package-lock.json         | node_modules                            | Installiert exakt die Abhängigkeiten des Projekts.                                |
| Lint (TypeScript / JS)            | cross-platform | Quellcode (JS/TS)                        | Lint-Report / Fehler                   | Prüft TypeScript- und JavaScript-Code auf Stil- und Syntax-Fehler.               |
| Ensure Vitest report dir exists   | cross-platform | -                                        | tests/node/ Verzeichnis                | Verzeichnis für JUnit-XML-Ergebnisse erstellen.                                    |
| Run Vitest and output JUnit XML   | cross-platform | Node-Tests                               | tests/node/vitest.xml                  | Führen der Unit-Tests aus und Ausgabe als JUnit XML für Test-Reporting.          |
| Ensure Busted output dir exists   | Windows / cross-platform | -                                | tests/lua/output/ Verzeichnis         | Verzeichnis für Lua/Busted-Testergebnisse erstellen.                               |
| Ensure Podman machine is running  | Windows        | Podman installed                         | laufende Podman-Maschine               | Bereitstellung einer Linux-VM für containerisierte Tests.                         |
| Run Lua tests (Busted) via container | cross-platform | Lua-Tests, container runtime           | tests/lua/output/busted.xml            | Führen von Lua-Unit-Tests innerhalb konsistenter Linux-Umgebung durch Container.  |
| Upload test-results artifact      | cross-platform | tests/node/vitest.xml, tests/lua/output/busted.xml | GitHub Artifact                       | Test-Ergebnisse werden als Artefakt gespeichert und für Reporting bereitgestellt. |
| Build client                       | cross-platform | Quellcode                                | dist/                                  | Produziert den gebauten Client-Code für Deployment oder weitere Verwendung.       |
| Upload Node build artifacts        | cross-platform | dist/                                     | GitHub Artifact                         | Der gebaute Client-Code wird als Artefakt verfügbar gemacht.                     |
```

**Kontext und Zusammenhänge:**

* **Self-Hosted Runner:** Alles läuft lokal oder auf eigener Maschine, wodurch Installation von Node, Lua und Tools vorher erledigt sein kann. Beschleunigt CI-Durchläufe.
* **Containerisierung:** Lua/Busted Tests laufen in einer Ubuntu-Umgebung, was OS-Unabhängigkeit sicherstellt.
* **Artefakte:** Sowohl Node-Tests als auch Lua-Tests werden als JUnit-XML exportiert und hochgeladen, damit der zweite Workflow (`test-report.yml`) CheckRuns erstellen kann.
* **Test Report Workflow:** Läuft nur auf dem Default-Branch, konsumiert die Artefakte und erstellt Reports in GitHub UI. Diese Trennung erlaubt Fork-PRs ohne Schreibrechte auf CheckRuns.

---

### Test-Report Workflow

```
| Job/Step                       | Platform       | Input/Resources                         | Output/Artifacts / GitHub UI       | Zweck/Beschreibung                                                                 |
|--------------------------------|----------------|----------------------------------------|-----------------------------------|-----------------------------------------------------------------------------------|
| Download test-results artifact  | cross-platform | GitHub Artifact "test-results"          | ./test-results/                     | Lädt die Artefakte herunter, die im CI-Workflow erzeugt wurden (Vitest + Busted).|
| List downloaded files (diagnose)| cross-platform | ./test-results/                          | Konsolen-Ausgabe                    | Kontrolliert, ob die Artefakte korrekt heruntergeladen wurden.                     |
| Publish Vitest JUnit report     | cross-platform | tests/node/vitest.xml aus Artifact      | GitHub CheckRun / PR UI            | Erstellt in GitHub UI ein CheckRun mit Vitest-Testergebnissen (Java-JUnit Format).|
| Publish Busted JUnit report     | cross-platform | tests/lua/output/busted.xml aus Artifact| GitHub CheckRun / PR UI            | Erstellt in GitHub UI ein CheckRun mit Busted-Testergebnissen (Java-JUnit Format).|
```

**Kontext und Zusammenhänge:**

* Dieser Workflow läuft **nur auf dem Default-Branch**, nachdem der CI-Workflow (`ci.yml`) erfolgreich abgeschlossen ist.
* Er nutzt `workflow_run`, um die Abhängigkeit sicherzustellen: Test-Reports werden erst generiert, nachdem die Artefakte von CI verfügbar sind.
* **Artefaktbasiert:** PRs von Forks können CI durchführen, selbst wenn keine Schreibrechte für CheckRuns existieren. Nur der Default-Branch kann die Reports in GitHub UI veröffentlichen.
* **Test-Reporting:** Durch `dorny/test-reporter@v2` werden die JUnit-XML-Dateien in CheckRuns umgesetzt, inklusive Zusammenfassung, Fehlermeldungen und Annotationen in Pull Requests.
* **Konfiguration:** `fail-on-empty: false` sorgt dafür, dass fehlende Testdateien nicht den Report-Job abbrechen. `only-summary` und `max-annotations` steuern, wie detailliert der Report angezeigt wird.

Damit ist die komplette CI-Kette aufgeteilt in:

1. **CI Workflow** → führt Tests aus, erstellt Artefakte.
2. **Test Report Workflow** → verarbeitet Artefakte, erstellt GitHub UI Reports.

Dies erlaubt sauberes Handling von Fork-PRs und konsistentes Reporting unabhängig vom Runner-OS.

---

## Kopfbereich CI 1

```yaml
name: CI
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
```

* `name: CI` – Name des Workflows.
* `on:` – Trigger-Bedingungen: Ausführung bei Pushes oder Pull Requests auf `main`.
* Dies ermöglicht, dass sowohl direkte Änderungen als auch PRs die Pipeline auslösen.

---

## Jobs

### build-and-test

```yaml
jobs:
  build-and-test:
    name: Build & Test
    runs-on: [self-hosted]
```

* `runs-on: [self-hosted]` – Nutzung eines eigenen Runners. Vorteile: Node.js, Lua, Podman, Cache bereits vorinstalliert → schnellere Durchläufe.
* Job-Name: “Build & Test”.

---

### Ausführungs-Schritte

#### Repository auschecken

```yaml
- name: Checkout repository
  uses: actions/checkout@v4
```

* Holt den Quellcode aus GitHub in den Runner-Workspace.
* Unverzichtbar, da alle weiteren Schritte den Code benötigen.

#### Node-Module Cache

```yaml
- name: Cache node modules
  uses: actions/cache@v4
  with:
    path: ~/.npm
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-node-
```

* Verhindert wiederholtes `npm ci` bei unveränderten Abhängigkeiten.
* Schlüssel basiert auf OS + Hash der `package-lock.json`.

#### Node-Abhängigkeiten installieren

```yaml
- name: Install dependencies
  run: npm ci
```

* Saubere Installation der Node.js-Pakete.

#### Linting

```yaml
- name: Lint (TypeScript / JS)
  run: npm run lint
```

* Statischer Code-Check für TypeScript/JS.

#### Vitest Test-Ordner vorbereiten

```yaml
- name: Ensure vitest report dir exists
  run: mkdir -p tests/node
```

* Stellt sicher, dass das Verzeichnis für JUnit-Ausgaben existiert.

#### Vitest ausführen

```yaml
- name: Run Vitest and output JUnit XML
  run: npm test -- --reporter=junit --outputFile=tests/node/vitest.xml
```

* Führt Node-Tests aus und erzeugt JUnit XML (`vitest.xml`) für die spätere Nutzung im Test-Report Workflow.

#### Lua-Testordner vorbereiten

```yaml
- name: Ensure busted output dir exists
  shell: pwsh
  run: |
    New-Item -ItemType Directory -Path tests/lua/output -Force | Out-Null
```

* PowerShell-Befehl für Windows Runner, erzeugt das Verzeichnis für Busted JUnit XML.

#### Podman-Maschine starten

```yaml
- name: Ensure Podman machine is running
  shell: pwsh
  run: |
    $machineStatus = podman machine list --format json | ConvertFrom-Json
    if ($machineStatus.Count -eq 0) { podman machine init }
    podman machine start
```

* Prüft, ob die Podman-VM läuft.
* Initialisiert und startet sie bei Bedarf.
* Wichtig für Windows Runner, da Podman nur über eine Linux-VM Container ausführt.

#### Lua-Tests via Container

```yaml
- name: Run Lua tests (Busted) via container
  shell: pwsh
  run: |
    $tool = if (Get-Command podman -ErrorAction SilentlyContinue) { "podman" } elseif (Get-Command docker -ErrorAction SilentlyContinue) { "docker" } else { "" }
    if ($tool -eq "") {
      Write-Host "Neither Podman nor Docker found on runner. Attempting native Linux installation if applicable."
      if ($env:RUNNER_OS -eq "Linux") {
        sudo apt-get update
        sudo apt-get install -y lua5.3 liblua5.3-dev luarocks build-essential
        luarocks install --local busted
      } else {
        Write-Host "Busted not available on this platform. Skipping Lua tests."
        exit 0
      }
    }
    if ($tool -ne "") {
      Write-Host "Using container runtime: $tool"
      & $tool run --rm -v "${{ github.workspace }}:/work" -w /work ubuntu:22.04 bash -lc `
        "apt-get update -qq && apt-get install -y -qq lua5.3 liblua5.3-dev luarocks build-essential && luarocks install --local busted && busted --pattern='*.spec.lua' --lpath='./?.lua' --output-junit=/work/tests/lua/output/busted.xml tests/lua || true"
    }
```

* Prüft, ob Podman oder Docker installiert ist.
* Wenn vorhanden, läuft Busted in einem kurzlebigen Ubuntu-Container → konsistente Linux-Umgebung für Tests.
* Wenn kein Container verfügbar, wird auf Linux-Runnern native Installation verwendet.
* Ziel: plattformunabhängige Ausführung der Lua-Tests und Ausgabe von `busted.xml`.

#### Test-Ergebnisse hochladen

```yaml
- name: Upload test-results artifact
  uses: actions/upload-artifact@v4
  if: always()
  with:
    name: test-results
    path: |
      tests/node/vitest.xml
      tests/lua/output/busted.xml
```

* Die erzeugten JUnit XML-Dateien werden als Artefakt hochgeladen.
* Später im separaten Workflow verwendet, um Testreports in der GitHub UI anzuzeigen.

#### Node-Build

```yaml
- name: Build client
  run: npm run build
```

* Baut das Client-Projekt.
* Getrennt vom Testprozess, kann aber parallel oder danach ausgeführt werden.

#### Node-Build-Artefakte hochladen

```yaml
- name: Upload Node build artifacts
  uses: actions/upload-artifact@v4
  with:
    name: node-build
    path: dist/
```

* Ermöglicht z.B. Download für Deployment oder Release.

---

# `.github/workflows/test-report.yml` – Zweite Stufe CI

**Zweck:**
Diese Pipeline wird nur auf dem Default-Branch ausgeführt, nachdem der erste CI-Workflow (`CI`) abgeschlossen ist.

* Lädt die Test-Ergebnisse als Artefakt herunter
* Erstellt GitHub CheckRuns für PR UI

---

### Kopfbereich

```yaml
name: Test Report
on:
  workflow_run:
    workflows: ['CI']
    types:
      - completed
```

* `workflow_run` – Trigger, sobald der Workflow `CI` abgeschlossen ist.
* Vorteil: Getrennte Logik für PRs von Forks, die ansonsten wegen Token-Beschränkungen keine CheckRuns erzeugen können.

```yaml
permissions:
  contents: read
  actions: read
  checks: write
```

* Notwendige GitHub-Permissions, um CheckRuns zu erstellen.

---

### Job: publish-report

```yaml
jobs:
  publish-report:
    name: Publish Test Report
    runs-on: ubuntu-latest
```

* Läuft auf gehostetem Ubuntu. Keine Self-Hosted Abhängigkeiten notwendig.

---

### Schritte

#### Artefakt herunterladen

```yaml
- name: Download test-results artifact
  uses: actions/download-artifact@v4
  with:
    name: test-results
    path: ./test-results
```

* Holt die XML-Dateien aus dem CI-Workflow.

#### Diagnose der Artefakte

```yaml
- name: List downloaded files (diagnose)
  run: |
    ls -R test-results || true
```

* Prüft, ob die XML-Dateien korrekt angekommen sind.

#### Vitest-Report veröffentlichen

```yaml
- name: Publish Vitest JUnit report
  uses: dorny/test-reporter@v2
  if: always()
  with:
    artifact: test-results
    name: Vitest
    path: 'tests/node/vitest.xml'
    reporter: java-junit
    fail-on-empty: false
    only-summary: 'false'
    max-annotations: '10'
```

* Erstellt CheckRuns für die Node-Tests in GitHub UI.
* `java-junit` Reporter unterstützt das von Vitest erzeugte XML-Format.

#### Busted-Report veröffentlichen

```yaml
- name: Publish Busted JUnit report
  uses: dorny/test-reporter@v2
  if: always()
  with:
    artifact: test-results
    name: Busted
    path: 'tests/lua/output/busted.xml'
    reporter: java-junit
    fail-on-empty: false
    only-summary: 'true'
    max-annotations: '5'
```

* Analog für Lua/Busted.
* `only-summary: true` – detaillierte Testfälle werden nicht als Annotationen erstellt, nur Zusammenfassung.

---

**Zusammenhang und Architektur:**

1. **`ci.yml`** – führt Tests, Build und Artefakte aus, ohne CheckRuns → PRs von Forks können trotzdem erfolgreich getestet werden.
2. **`test-report.yml`** – läuft auf Default-Branch, erstellt CheckRuns basierend auf hochgeladenen Artefakten.
3. **Self-Hosted Runner** → schneller, mit allen Abhängigkeiten vorinstalliert.
4. **Container für Busted** → plattformunabhängig, konsistente Linux-Umgebung für Lua-Tests.
5. **Artefakte** → Trennung von Testausführung und Reporting, verhindert Probleme bei PRs von Forks.

---

Wenn gewünscht, kann ich auch noch **ein Diagramm/Flow-Schema** erstellen, das die Schritte und Abhängigkeiten visuell zeigt – sehr nützlich, um die Pipeline in großen Projekten zu dokumentieren.

Willst du, dass ich das mache?
